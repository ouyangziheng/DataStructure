# 图

## 算法讲解

1. 图的数据记录方式
    1. 邻接矩阵—通过矩阵的ij个元素的方式，可以储存两个点之间的具体权重
    2. 邻接表—为每一个节点建立一个链表，一般记录所有的出度，当然也可以记录入度
2. 图的性质判定（邻接矩阵）
    1. 有向：直接判断矩阵是否沿着对角线对称即可
    2. 有环：使用栈进行，栈中出现了相同元素即为有环
    3. 联通：深度搜索和广度搜索节点，节点总数正确即可
3. 图的遍历方式
    1. 广度优先搜索
        1. 对于邻接表，对节点进行遍历，每一个节点引出新的节点，放到队列之中
        2. 对于领接矩阵，与之类似，直接进行矩阵的遍历即可
        3. 可以用于最短路径的获取
    2. 深度优先搜索
        1. 和广度优先搜索类似，换成使用栈结构
        2. 深度优先搜索可以用作对图的拓扑排序
4. 拓扑排序
    1. 入度法
        1. 首先将入度为0的点加入队列（说明这个点可以直接被运行）
        2. 然后将与之相连节点的入度-1
        3. 遍历更新入度为0的点
    2. 出度法
        1. 这个思路与之相反，如果一个元素没有出度，那么他将会是最后被做的一个任务
        2. 这个思路的本质逻辑是递归到最深层的节点不存在出度，故最后完成，然后他前面的任务将不会存在出度，故可以处理前面的节点
        3. 最后将结果栈进行翻转即可
5. 生成树
    1. 首先，对于最小生成树和最大生成树实际上是一样的，相当于在优化的时候重载了比较的运算符，更换成相反的逻辑即可，或者以一种更直接的方式，直接对每个节点的数值去负号，这间接相当于对结果进行了负的最小优化，在此取反后获取最大值
    2. def：生成树（图）包含所有节点的无环子图，子图联通
    3. Prim算法：使用最小堆。每次找到一个新的节点，将该点连接的边放到最小堆之中，获取一个最小的边即可，在理解上面，每一次加入新的边都满足最小的原则，从而使得整体更小
    4. Kruskal算法：直接找到最小的n-1条边，n-1条边一定能连接所有n个节点，故获取了最小生成树
6. 最短路径—Dijkstra 算法
    1. 原理—单调性：我们确定了源点 ***u*** 到某个其它的点 ***v*** 的最短路径时，在这个最短路径的具体路线中，若有一个中转点 ***t***，那么在这个最短路径中从源点 ***u*** 到 ***t*** 的路径也一定是 ***u*** 到 ***t*** 的**最短路径**之一
    2. 对于每一个节点，尝试更新与之相连接的所有节点，循环测试新的生成路径是否能比原先更小即可，如果小的话，对权重进行更新
   
## 测试

1. 首先需要建立图 MyMap
2. 然后逐个建立节点 Node
3. 将节点加入到图中，调用MyMap的`addNode`方法
4. 设置权重
   1. 对于有向图，调用MyMap的`setValueToMatrixForDirectedGraph`方法，其参数列表为（节点1，节点2，权重），表示建立从节点1到节点2的有权有向路径
   2. 对于无向图，调用MyMap的`setValueToMatrixForUndirectedGraph`方法，其参数列表为（节点1，节点2，权重），表示建立从节点1到节点2的有权无向路径
5. 后续解释函数的API
   1. `isDirectedGraph()`判断当前图是否为有向图
   2. `isDAG()`判断当前图是否为有向无环图
   3. `isConnectedGraph()`判断当前图是否为连通图。
   4. `depthFirstTraverse(int startNode)`执行深度优先遍历（DFS）。

   5. `resetNode()`重置图中所有节点的状态。

   6. `topologicalSortWithStack()`执行拓扑排序（适用于有向无环图）。
   7. `breadthFirstTraverse(int startNode)`广度优先遍历（BFS）。

   8. `primTree(int startNode)`执行普里姆算法，计算最小生成树（MST）。
   9. `kruskalTree()`执行克鲁斯卡尔算法，计算最小生成树（MST）。
   10. `dijkstra(int startNode)`执行 Dijkstra 算法，计算最短路径。
   1.  `bellmanFord(int startNode)`执行 Bellman-Ford 算法，计算最短路径。




